<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Tracking</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      video {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform: scaleX(-1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <video class="input_video" autoplay muted playsinline></video>
      <canvas class="guides"></canvas>
    </div>

    <script>
      const video = document.querySelector(".input_video");
      const canvas = document.querySelector(".guides");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // --- Smoothing Filter State ---
      let smoothedHands = []; 
      const lerp = (a, b, t) => a + (b - a) * t;
      const ALPHA = 0.4; // ค่าความนิ่ง (0.1-1): ยิ่งเข้าน้อยยิ่งนิ่งแต่จะหน่วงขึ้น

      /* -------------------------------------------------------
         Mapping: Mediapipe x,y (0–1) → Pixel on screen
      -------------------------------------------------------- */
      function mapPoint(x, y, videoWidth, videoHeight, canvasWidth, canvasHeight) {
        const videoRatio = videoWidth / videoHeight;
        const canvasRatio = canvasWidth / canvasHeight;

        let drawWidth, drawHeight;
        if (canvasRatio > videoRatio) {
          drawWidth = canvasWidth;
          drawHeight = canvasWidth / videoRatio;
        } else {
          drawHeight = canvasHeight;
          drawWidth = canvasHeight * videoRatio;
        }

        const scale = drawWidth / videoWidth;
        const offsetX = (canvasWidth - drawWidth) / 2;
        const offsetY = (canvasHeight - drawHeight) / 2;

        const px = x * videoWidth * scale + offsetX;
        const py = y * videoHeight * scale + offsetY;

        return { x: px, y: py };
      }

      function drawMappedLandmarks(landmarks, color = "red", size = 3) {
        ctx.fillStyle = color;
        for (let lm of landmarks) {
          const p = mapPoint(
            lm.x,
            lm.y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawMappedLines(ptsA, ptsB, color = "cyan", width = 2) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;

        for (let [a, b] of ptsB) {
          if (!ptsA[a] || !ptsA[b]) continue;
          const A = mapPoint(
            ptsA[a].x,
            ptsA[a].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          const B = mapPoint(
            ptsA[b].x,
            ptsA[b].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );

          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        }
      }

      function drawPalmPlane(landmarks, color = "rgba(255, 255, 255, 0.3)") {
        const indices = [0, 5, 17];
        const points = indices.map(i => mapPoint(
          landmarks[i].x,
          landmarks[i].y,
          video.videoWidth,
          video.videoHeight,
          canvas.width,
          canvas.height
        ));

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fill();
        
        // วาดขอบด้วย
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawHandOrigin(landmarks) {
        // 1. จุดอ้างอิงระนาบ
        const p0 = landmarks[0];   // Wrist
        const p5 = landmarks[5];   // Index base
        const p17 = landmarks[17]; // Pinky base

        // 2. เวกเตอร์ฐาน (Z-Axis / Normal)
        const v1 = { x: p5.x - p0.x, y: p5.y - p0.y, z: p5.z - p0.z };
        const v2 = { x: p17.x - p0.x, y: p17.y - p0.y, z: p17.z - p0.z };
        
        // Normal Vector (Z)
        const nz_raw = {
          x: v1.y * v2.z - v1.z * v2.y,
          y: v1.z * v2.x - v1.x * v2.z,
          z: v1.x * v2.y - v1.y * v2.x
        };
        const lenZ = Math.sqrt(nz_raw.x**2 + nz_raw.y**2 + nz_raw.z**2);
        const vZ = { x: nz_raw.x/lenZ, y: nz_raw.y/lenZ, z: nz_raw.z/lenZ };

        // 3. แกน X (ขนานกับ 5 -> 17)
        const vx_raw = { x: p17.x - p5.x, y: p17.y - p5.y, z: p17.z - p5.z };
        const lenX = Math.sqrt(vx_raw.x**2 + vx_raw.y**2 + vx_raw.z**2);
        const vX = { x: vx_raw.x/lenX, y: vx_raw.y/lenX, z: vx_raw.z/lenX };

        // 4. แกน Y (ตั้งฉากกับ X และ Z) - Cross Product อีกรอบ
        const vY = {
          x: vZ.y * vX.z - vZ.z * vX.x,
          y: vZ.z * vX.x - vZ.x * vX.z,
          z: vZ.x * vX.y - vZ.y * vX.x
        };

        // 5. จุดกึ่งกลาง (Origin)
        const mid = {
          x: (p0.x + p5.x + p17.x) / 3,
          y: (p0.y + p5.y + p17.y) / 3,
          z: (p0.z + p5.z + p17.z) / 3
        };

        const origin = mapPoint(mid.x, mid.y, video.videoWidth, video.videoHeight, canvas.width, canvas.height);
        const scale = 0.15; // ความยาวแกน

        // ฟังก์ชันช่วยวาดแกน
        const drawAxis = (v, color, label) => {
          const target = mapPoint(mid.x + v.x * scale, mid.y + v.y * scale, video.videoWidth, video.videoHeight, canvas.width, canvas.height);
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
          
          ctx.fillStyle = color;
          ctx.font = "bold 16px Arial";
          ctx.fillText(label, target.x, target.y);
        };

        // วาดทั้ง 3 แกน
        drawAxis(vX, "red", "X");      // แกน X - ขนานหน้ามือ
        drawAxis(vY, "#00ff00", "Y");  // แกน Y - พุ่งไปทางปลายนิ้ว
        drawAxis(vZ, "dodgerblue", "Z"); // แกน Z - พุ่งออกจากฝ่ามือ (Normal)

        // วาดจุด Origin
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      /* -------------------------------------------------------
         Mediapipe Hands Setup
      -------------------------------------------------------- */
      const hands = new Hands({
        locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
      });

      hands.onResults((results) => {
        // อัปเดตข้อมูล landmarks แบบผ่าน Filter
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          if (smoothedHands.length !== results.multiHandLandmarks.length) {
            smoothedHands = JSON.parse(JSON.stringify(results.multiHandLandmarks));
          } else {
            // Apply Smoothing (EMA)
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
              for (let j = 0; j < results.multiHandLandmarks[i].length; j++) {
                smoothedHands[i][j].x = lerp(smoothedHands[i][j].x, results.multiHandLandmarks[i][j].x, ALPHA);
                smoothedHands[i][j].y = lerp(smoothedHands[i][j].y, results.multiHandLandmarks[i][j].y, ALPHA);
                smoothedHands[i][j].z = lerp(smoothedHands[i][j].z, results.multiHandLandmarks[i][j].z, ALPHA);
              }
            }
          }
        } else {
          smoothedHands = [];
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!video.videoWidth) return;

        if (smoothedHands.length > 0) {
          smoothedHands.forEach((landmarks, index) => {
            const handedness = results.multiHandedness[index].label;
            const isRight = handedness === "Right";
            const color = isRight ? "lime" : "yellow";
            
            // วาด plane ตรงฝ่ามือ (0, 5, 17)
            drawPalmPlane(landmarks, isRight ? "rgba(0, 255, 0, 0.2)" : "rgba(255, 255, 0, 0.2)");

            // วาดระบบพิกัด 3D Origin (X, Y, Z)
            drawHandOrigin(landmarks);

            // HAND_CONNECTIONS is provided by hands.js / drawing_utils.js
            if (typeof HAND_CONNECTIONS !== 'undefined') {
              drawMappedLines(landmarks, HAND_CONNECTIONS, color, 4);
            }
            drawMappedLandmarks(landmarks, "red", 3);
          });
        }
      });

      // Camera
      const camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 1280,
        height: 720,
      });
      camera.start();
    </script>
  </body>
</html>
