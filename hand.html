<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Tracking</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      video {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform: scaleX(-1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <video class="input_video" autoplay muted playsinline></video>
      <canvas class="guides"></canvas>
    </div>

    <script>
      const video = document.querySelector(".input_video");
      const canvas = document.querySelector(".guides");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // --- Smoothing Filter State ---
      let smoothedHands = []; 
      const lerp = (a, b, t) => a + (b - a) * t;
      const ALPHA = 0.4; // ค่าความนิ่ง (0.1-1): ยิ่งเข้าน้อยยิ่งนิ่งแต่จะหน่วงขึ้น

      /* -------------------------------------------------------
         Mapping: Mediapipe x,y (0–1) → Pixel on screen
      -------------------------------------------------------- */
      function mapPoint(x, y, videoWidth, videoHeight, canvasWidth, canvasHeight) {
        const videoRatio = videoWidth / videoHeight;
        const canvasRatio = canvasWidth / canvasHeight;

        let drawWidth, drawHeight;
        if (canvasRatio > videoRatio) {
          drawWidth = canvasWidth;
          drawHeight = canvasWidth / videoRatio;
        } else {
          drawHeight = canvasHeight;
          drawWidth = canvasHeight * videoRatio;
        }

        const scale = drawWidth / videoWidth;
        const offsetX = (canvasWidth - drawWidth) / 2;
        const offsetY = (canvasHeight - drawHeight) / 2;

        const px = x * videoWidth * scale + offsetX;
        const py = y * videoHeight * scale + offsetY;

        return { x: px, y: py };
      }

      function drawMappedLandmarks(landmarks, color = "red", size = 3) {
        ctx.fillStyle = color;
        for (let lm of landmarks) {
          const p = mapPoint(
            lm.x,
            lm.y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawMappedLines(ptsA, ptsB, color = "cyan", width = 2) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;

        for (let [a, b] of ptsB) {
          if (!ptsA[a] || !ptsA[b]) continue;
          const A = mapPoint(
            ptsA[a].x,
            ptsA[a].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          const B = mapPoint(
            ptsA[b].x,
            ptsA[b].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );

          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        }
      }

      function drawPalmPlane(landmarks, color = "rgba(255, 255, 255, 0.3)") {
        const indices = [0, 5, 17];
        const points = indices.map(i => mapPoint(
          landmarks[i].x,
          landmarks[i].y,
          video.videoWidth,
          video.videoHeight,
          canvas.width,
          canvas.height
        ));

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fill();
        
        // วาดขอบด้วย
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawHandNormal(landmarks) {
        // 1. จุดอ้างอิงระนาบ
        const p0 = landmarks[0];  // Wrist
        const p5 = landmarks[5];  // Index base
        const p17 = landmarks[17]; // Pinky base

        // 2. หาเวกเตอร์บนระนาบ
        const v1 = { x: p5.x - p0.x, y: p5.y - p0.y, z: p5.z - p0.z };
        const v2 = { x: p17.x - p0.x, y: p17.y - p0.y, z: p17.z - p0.z };

        // 3. Cross Product เพื่อหา Normal Vector (ตั้งฉาก)
        const nx = v1.y * v2.z - v1.z * v2.y;
        const ny = v1.z * v2.x - v1.x * v2.z;
        const nz = v1.x * v2.y - v1.y * v2.x;

        // Normalize (ทำให้ยาวพอเหมาะ)
        const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
        const scale = 0.2; // ความยาวเส้น
        const normal = { x: (nx/len) * scale, y: (ny/len) * scale };

        // 4. จุดกึ่งกลางระนาบ (Origin)
        const midX = (p0.x + p5.x + p17.x) / 3;
        const midY = (p0.y + p5.y + p17.y) / 3;

        const start = mapPoint(midX, midY, video.videoWidth, video.videoHeight, canvas.width, canvas.height);
        const end = mapPoint(midX + normal.x, midY + normal.y, video.videoWidth, video.videoHeight, canvas.width, canvas.height);

        // 5. วาดเส้นตั้งฉาก
        ctx.strokeStyle = "#ff00ff"; // สีชมพูสะท้อนแสง
        ctx.lineWidth = 5;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();

        // 6. วาดจุดกึ่งกลาง (Pivot)
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      /* -------------------------------------------------------
         Mediapipe Hands Setup
      -------------------------------------------------------- */
      const hands = new Hands({
        locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
      });

      hands.onResults((results) => {
        // อัปเดตข้อมูล landmarks แบบผ่าน Filter
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          if (smoothedHands.length !== results.multiHandLandmarks.length) {
            smoothedHands = JSON.parse(JSON.stringify(results.multiHandLandmarks));
          } else {
            // Apply Smoothing (EMA)
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
              for (let j = 0; j < results.multiHandLandmarks[i].length; j++) {
                smoothedHands[i][j].x = lerp(smoothedHands[i][j].x, results.multiHandLandmarks[i][j].x, ALPHA);
                smoothedHands[i][j].y = lerp(smoothedHands[i][j].y, results.multiHandLandmarks[i][j].y, ALPHA);
                smoothedHands[i][j].z = lerp(smoothedHands[i][j].z, results.multiHandLandmarks[i][j].z, ALPHA);
              }
            }
          }
        } else {
          smoothedHands = [];
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!video.videoWidth) return;

        if (smoothedHands.length > 0) {
          smoothedHands.forEach((landmarks, index) => {
            const handedness = results.multiHandedness[index].label;
            const isRight = handedness === "Right";
            const color = isRight ? "lime" : "yellow";
            
            // วาด plane ตรงฝ่ามือ (0, 5, 17)
            drawPalmPlane(landmarks, isRight ? "rgba(0, 255, 0, 0.2)" : "rgba(255, 255, 0, 0.2)");

            // วาดเส้นตั้งฉากจากระนาบฝ่ามือ
            drawHandNormal(landmarks);

            // HAND_CONNECTIONS is provided by hands.js / drawing_utils.js
            if (typeof HAND_CONNECTIONS !== 'undefined') {
              drawMappedLines(landmarks, HAND_CONNECTIONS, color, 4);
            }
            drawMappedLandmarks(landmarks, "red", 3);
          });
        }
      });

      // Camera
      const camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 1280,
        height: 720,
      });
      camera.start();
    </script>
  </body>
</html>
