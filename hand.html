<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Tracking</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      video {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform: scaleX(-1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <video class="input_video" autoplay muted playsinline></video>
      <canvas class="guides"></canvas>
    </div>

    <script>
      const video = document.querySelector(".input_video");
      const canvas = document.querySelector(".guides");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      /* -------------------------------------------------------
         Mapping: Mediapipe x,y (0–1) → Pixel on screen
      -------------------------------------------------------- */
      function mapPoint(x, y, videoWidth, videoHeight, canvasWidth, canvasHeight) {
        const videoRatio = videoWidth / videoHeight;
        const canvasRatio = canvasWidth / canvasHeight;

        let drawWidth, drawHeight;
        if (canvasRatio > videoRatio) {
          drawWidth = canvasWidth;
          drawHeight = canvasWidth / videoRatio;
        } else {
          drawHeight = canvasHeight;
          drawWidth = canvasHeight * videoRatio;
        }

        const scale = drawWidth / videoWidth;
        const offsetX = (canvasWidth - drawWidth) / 2;
        const offsetY = (canvasHeight - drawHeight) / 2;

        const px = x * videoWidth * scale + offsetX;
        const py = y * videoHeight * scale + offsetY;

        return { x: px, y: py };
      }

      function drawMappedLandmarks(landmarks, color = "red", size = 3) {
        ctx.fillStyle = color;
        for (let lm of landmarks) {
          const p = mapPoint(
            lm.x,
            lm.y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawMappedLines(ptsA, ptsB, color = "cyan", width = 2) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;

        for (let [a, b] of ptsB) {
          if (!ptsA[a] || !ptsA[b]) continue;
          const A = mapPoint(
            ptsA[a].x,
            ptsA[a].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          const B = mapPoint(
            ptsA[b].x,
            ptsA[b].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );

          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        }
      }

      function drawPalmPlane(landmarks, color = "rgba(255, 255, 255, 0.3)") {
        const indices = [0, 5, 17];
        const points = indices.map(i => mapPoint(
          landmarks[i].x,
          landmarks[i].y,
          video.videoWidth,
          video.videoHeight,
          canvas.width,
          canvas.height
        ));

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fill();
        
        // วาดขอบด้วย
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      /* -------------------------------------------------------
         Mediapipe Hands Setup
      -------------------------------------------------------- */
      const hands = new Hands({
        locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
      });

      hands.onResults((results) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!video.videoWidth) return;

        if (results.multiHandLandmarks) {
          results.multiHandLandmarks.forEach((landmarks, index) => {
            const handedness = results.multiHandedness[index].label;
            const isRight = handedness === "Right";
            const color = isRight ? "lime" : "yellow";
            
            // วาด plane ตรงฝ่ามือ (0, 5, 17)
            drawPalmPlane(landmarks, isRight ? "rgba(0, 255, 0, 0.3)" : "rgba(255, 255, 0, 0.3)");

            // HAND_CONNECTIONS is provided by hands.js / drawing_utils.js
            if (typeof HAND_CONNECTIONS !== 'undefined') {
              drawMappedLines(landmarks, HAND_CONNECTIONS, color, 4);
            }
            drawMappedLandmarks(landmarks, "red", 3);
          });
        }
      });

      // Camera
      const camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 1280,
        height: 720,
      });
      camera.start();
    </script>
  </body>
</html>
