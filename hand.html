<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Tracking</title>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      video {
        position: absolute;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform: scaleX(-1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <video class="input_video" autoplay muted playsinline></video>
      <canvas class="guides"></canvas>
    </div>

    <script>
      const video = document.querySelector(".input_video");
      const canvas = document.querySelector(".guides");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // --- Smoothing Filter State ---
      let smoothedHands = []; 
      const lerp = (a, b, t) => a + (b - a) * t;
      const ALPHA = 0.4; // ค่าความนิ่ง (0.1-1): ยิ่งเข้าน้อยยิ่งนิ่งแต่จะหน่วงขึ้น

      /* -------------------------------------------------------
         Mapping: Mediapipe x,y (0–1) → Pixel on screen
      -------------------------------------------------------- */
      function mapPoint(x, y, videoWidth, videoHeight, canvasWidth, canvasHeight) {
        const videoRatio = videoWidth / videoHeight;
        const canvasRatio = canvasWidth / canvasHeight;

        let drawWidth, drawHeight;
        if (canvasRatio > videoRatio) {
          drawWidth = canvasWidth;
          drawHeight = canvasWidth / videoRatio;
        } else {
          drawHeight = canvasHeight;
          drawWidth = canvasHeight * videoRatio;
        }

        const scale = drawWidth / videoWidth;
        const offsetX = (canvasWidth - drawWidth) / 2;
        const offsetY = (canvasHeight - drawHeight) / 2;

        const px = x * videoWidth * scale + offsetX;
        const py = y * videoHeight * scale + offsetY;

        return { x: px, y: py };
      }

      function drawMappedLandmarks(landmarks, color = "red", size = 3) {
        ctx.fillStyle = color;
        for (let lm of landmarks) {
          const p = mapPoint(
            lm.x,
            lm.y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawMappedLines(ptsA, ptsB, color = "cyan", width = 2) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;

        for (let [a, b] of ptsB) {
          if (!ptsA[a] || !ptsA[b]) continue;
          const A = mapPoint(
            ptsA[a].x,
            ptsA[a].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );
          const B = mapPoint(
            ptsA[b].x,
            ptsA[b].y,
            video.videoWidth,
            video.videoHeight,
            canvas.width,
            canvas.height
          );

          ctx.beginPath();
          ctx.moveTo(A.x, A.y);
          ctx.lineTo(B.x, B.y);
          ctx.stroke();
        }
      }

      function drawPalmPlane(landmarks, color = "rgba(255, 255, 255, 0.3)") {
        const indices = [0, 5, 17];
        const points = indices.map(i => mapPoint(
          landmarks[i].x,
          landmarks[i].y,
          video.videoWidth,
          video.videoHeight,
          canvas.width,
          canvas.height
        ));

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fill();
        
        // วาดขอบด้วย
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawBottleFrame(landmarks, vX, vY, vZ, color) {
        // 1. คำนวณความงอของนิ้ว (Grip Strength)
        // วัดระยะจากปลายนิ้วเฉลี่ย (8, 12, 16, 20) ไปยังกลางฝ่ามือ (9)
        const tips = [8, 12, 16, 20];
        let avgCurl = 0;
        tips.forEach(t => {
          const dist = Math.sqrt(
            (landmarks[t].x - landmarks[9].x)**2 + 
            (landmarks[t].y - landmarks[9].y)**2 + 
            (landmarks[t].z - landmarks[9].z)**2
          );
          avgCurl += dist;
        });
        avgCurl /= tips.length;

        // 2. ตำแหน่งศูนย์กลางขวด (Offset จากฝ่ามือตามแนว Normal Z)
        // ถ้านิ้วแบ (avgCurl มาก) ให้ขวดลอยห่าง / ถ้านิ้วกำ (avgCurl น้อย) ให้ขวดชิดฝ่ามือ
        const baseOffset = 0.05; // ระยะห่างพื้นฐาน
        const dynamicOffset = baseOffset + (avgCurl * 0.2); 
        
        const midPalm = landmarks[9]; // ใช้โคนนิ้วกลางเป็นจุดยึดหลัก
        const bottlePos = {
          x: midPalm.x + vZ.x * dynamicOffset,
          y: midPalm.y + vZ.y * dynamicOffset,
          z: midPalm.z + vZ.z * dynamicOffset
        };

        const origin = mapPoint(bottlePos.x, bottlePos.y, video.videoWidth, video.videoHeight, canvas.width, canvas.height);
        
        // 3. วาดแกนขวด (ขนานกับแกน X)
        const bottleLen = 0.4;
        const start3D = {
          x: bottlePos.x - vX.x * bottleLen/2,
          y: bottlePos.y - vX.y * bottleLen/2
        };
        const end3D = {
          x: bottlePos.x + vX.x * bottleLen/2,
          y: bottlePos.y + vX.y * bottleLen/2
        };

        const start = mapPoint(start3D.x, start3D.y, video.videoWidth, video.videoHeight, canvas.width, canvas.height);
        const end = mapPoint(end3D.x, end3D.y, video.videoWidth, video.videoHeight, canvas.width, canvas.height);

        // วาดแกนกลางขวด
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        
        // วาดวงรีจำลองหัวท้ายขวด
        const drawEndCap = (p) => {
          ctx.beginPath();
          ctx.ellipse(p.x, p.y, 30, 15, Math.atan2(vX.y, vX.x), 0, Math.PI * 2);
          ctx.stroke();
        };
        drawEndCap(start);
        drawEndCap(end);
        
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "white";
        ctx.font = "bold 14px Arial";
        ctx.fillText("BOTTLE AXIS", origin.x - 40, origin.y - 10);
      }

      function drawHandOrigin(landmarks, handedness) {
        const p0 = landmarks[0];
        const p5 = landmarks[5];
        const p17 = landmarks[17];

        const v1 = { x: p5.x - p0.x, y: p5.y - p0.y, z: p5.z - p0.z };
        const v2 = { x: p17.x - p0.x, y: p17.y - p0.y, z: p17.z - p0.z };
        
        // Normal Vector (Z)
        let nz_raw = {
          x: v1.y * v2.z - v1.z * v2.y,
          y: v1.z * v2.x - v1.x * v2.z,
          z: v1.x * v2.y - v1.y * v2.x
        };

        // --- ฟลิบทิศทางใหม่สำหรับ "มือขวา" เพื่อให้พุ่งออกหน้ามือตามมุมมองกล้อง ---
        if (handedness === "Right") {
          nz_raw = { x: -nz_raw.x, y: -nz_raw.y, z: -nz_raw.z };
        }

        const lenZ = Math.sqrt(nz_raw.x**2 + nz_raw.y**2 + nz_raw.z**2);
        const vZ = { x: nz_raw.x/lenZ, y: nz_raw.y/lenZ, z: nz_raw.z/lenZ };

        // แกน X (5 -> 17)
        const vx_raw = { x: p17.x - p5.x, y: p17.y - p5.y, z: p17.z - p5.z };
        const lenX = Math.sqrt(vx_raw.x**2 + vx_raw.y**2 + vx_raw.z**2);
        const vX = { x: vx_raw.x/lenX, y: vx_raw.y/lenX, z: vx_raw.z/lenX };

        // แกน Y (ตั้งฉากกับ X และ Z)
        const vY = {
          x: vZ.y * vX.z - vZ.z * vX.x,
          y: vZ.z * vX.x - vZ.x * vX.z,
          z: vZ.x * vX.y - vZ.y * vX.x
        };

        // วาดขวดจำลองด้วยวิธี Hybrid
        drawBottleFrame(landmarks, vX, vY, vZ, "cyan");

        // วาดจุด Origin 
        const mid = {
          x: (p0.x + p5.x + p17.x) / 3,
          y: (p0.y + p5.y + p17.y) / 3
        };
        const origin = mapPoint(mid.x, mid.y, video.videoWidth, video.videoHeight, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "cyan";
        ctx.fillText(handedness, origin.x - 20, origin.y + 20);
      }

      /* -------------------------------------------------------
         Mediapipe Hands Setup
      -------------------------------------------------------- */
      const hands = new Hands({
        locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
      });

      hands.onResults((results) => {
        // อัปเดตข้อมูล landmarks แบบผ่าน Filter
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          if (smoothedHands.length !== results.multiHandLandmarks.length) {
            smoothedHands = JSON.parse(JSON.stringify(results.multiHandLandmarks));
          } else {
            // Apply Smoothing (EMA)
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
              for (let j = 0; j < results.multiHandLandmarks[i].length; j++) {
                smoothedHands[i][j].x = lerp(smoothedHands[i][j].x, results.multiHandLandmarks[i][j].x, ALPHA);
                smoothedHands[i][j].y = lerp(smoothedHands[i][j].y, results.multiHandLandmarks[i][j].y, ALPHA);
                smoothedHands[i][j].z = lerp(smoothedHands[i][j].z, results.multiHandLandmarks[i][j].z, ALPHA);
              }
            }
          }
        } else {
          smoothedHands = [];
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!video.videoWidth) return;

        if (smoothedHands.length > 0) {
          smoothedHands.forEach((landmarks, index) => {
            const handedness = results.multiHandedness[index].label;
            const isRight = handedness === "Right";
            const color = isRight ? "lime" : "yellow";
            
            // วาด plane ตรงฝ่ามือ (0, 5, 17)
            drawPalmPlane(landmarks, isRight ? "rgba(0, 255, 0, 0.2)" : "rgba(255, 255, 0, 0.2)");

            // วาดระบบพิกัด 3D Origin (X, Y, Z) - พาสค่า handedness ไปด้วย
            drawHandOrigin(landmarks, results.multiHandedness[index].label);

            // HAND_CONNECTIONS is provided by hands.js / drawing_utils.js
            if (typeof HAND_CONNECTIONS !== 'undefined') {
              drawMappedLines(landmarks, HAND_CONNECTIONS, color, 4);
            }
            drawMappedLandmarks(landmarks, "red", 3);
          });
        }
      });

      // Camera
      const camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 1280,
        height: 720,
      });
      camera.start();
    </script>
  </body>
</html>
